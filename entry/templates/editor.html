{% extends 'base.html' %}

{% block title %}Upload new Entry{% endblock %}

{% block head_script %}{% endblock %}

{% block body_script %}
<script>
var canv, ctx, canv_b, ctx_b, images = null, mouseStatus = 0, deck_img_data=null;
var bbox = {x: 0, y: 0}
//mouseStati:
//0: inactive - not on the canvas element
//1: active
//2: focused - hovering over image
//3: dragging
//4: scaling
//5: cropping
var INACTIVE = 0, ACTIVE = 1, FOCUSED = 2, DRAGGING = 4, SCALING = 8, CROPPING = 16;
var NODE_DIM = 8;
var btogs = function() {
	if($('#editpage').is(':hidden')) {
			$('#previewpage').fadeToggle(function() {
				$('#editpage').fadeToggle();
			});
	} else {
		$('#editpage').fadeToggle(function() {
			/*
			//getting right image dimensions is a bit hard
			//make new canvas (196x54)
			var vsc, hsc, n_x, n_y;
			canv_b.width = 54;
			canv_b.height = 196;
			//define ratio between 196x54 canvas and editing canvas
			vsc = canv_b.height / canv.height;
			hsc = canv_b.width / canv.width;
			//get coords of image, relate to center of canvases
			n_x = images.x * hsc;
			n_y = images.y * vsc;
			//fill color
			ctx_b.drawImage(
			//blit
			//get image for image and input tags
			*/
			if(canv.height < 196 + NODE_DIM) canv.height = 196 + NODE_DIM;
			if(images.h < 196) {
				images.csc = 196/images.i.height;
			}
			if(canv.height < 196) canv.height = 196;
			w = h * 3/11;
			updateScreen();
			deck_img_data = ctx.getImageData(canv.width/2 - w/2, NODE_DIM/2, w, h);
			canv_b.width = deck_img_data.width + 2;
			canv_b.height = deck_img_data.height + 2;
			ctx_b.putImageData(deck_img_data, 1, 1);
			ctx_b.lineWidth = 2.0;
			ctx_b.strokeRect(-1,-1,canv_b.width+1, canv_b.height+1);
			deck_img = canv_b.toDataURL('image/png');
			$('#deckprev')[0].src = deck_img;
			$('input[name=deck]')[0].value = deck_img;
			$('#previewpage').fadeToggle();
		}); 
	} 
}

function init_editor() {
    canv = $('#editor')[0];
    canv_b = $('#processor')[0];
    ctx = canv.getContext('2d');
    ctx_b = canv_b.getContext('2d');
    $(window).resize(resizeCanvas);
    $(window).trigger('resize');
    $('#previewpage').hide();
	$('#imagely').on('change', handleFileSelect);
}

function resizeCanvas(e) {
    canv.width = $(window).width() * .9;
    canv.height = ($(window).height() - $('#editpage').offset().top) * .9;
    if(images) { 
    	if(images.csc < 1 && (images.i.width < canv.width || images.i.height < canv.height)) {
    		images.csc = 1;
    	}
		if(images.i.width >= (canv.width)) { images.csc = (canv.width) / images.i.width; }
		if(images.i.height >= (canv.height) && (canv.height) / images.i.height < images.csc) { //more likely
			images.csc = (canv.height) / images.i.height; 
		}
		updateScreen(e);
		$('input[type=checkbox]').on('click', updateScreen);
    }
}

function handleFileSelect(e) {
    var i = e.target.files[0];
    var r = new FileReader();
    r.onload = (function(f) {
        return (function(e) {
            var i = new Image();
            i.onload = (function() {
                images = {i:i, x:canv.width/i.width, y:canv.height/i.height, r:0, csc: 1, //csc = canvas scaling constant, ratio to scale image to to fit canvas
                			get w() {
                				return this.i.width * this.csc; //will factor user scaling
                			}, 
                			get h() {
                				return this.i.height * this.csc;
                			}}; 
                resizeCanvas(e);
		$('#editor').on('mouseenter', handleMouse);
                $('#editor').on('mouseleave', handleMouse);
                $('input[name=preview]').on('click', btogs);
		$('input[name=goback]').on('click', btogs);
		$('#bgcolor').on('change', updateScreen);
                	
            });
            i.src = e.target.result;
        });
    })(i);
    r.readAsDataURL(i);
}

function handleMouse(e) { //this is going to be an object eventually
	var xo = (images.hasOwnProperty('new_x') ? images.new_x : images.x) + $('#editor').offset().left;
	var yo = (images.hasOwnProperty('new_y') ? images.new_y : images.y) + $('#editor').offset().top;
	var mouseInRect = (function(px, py, rx, ry, rw, rh) {
		return ((px >= rx && px <= rx + rw) && (py >= ry && py <= ry + rh));
	});
	var mouseInImage = (function(px, py) {
		return mouseInRect(px, py, xo + NODE_DIM/2, yo + NODE_DIM/2, images.w-NODE_DIM/2, images.h-NODE_DIM/2);
	});
	var mouseInNode = (function(px, py, north, west) { //north/west are booleans: true = north (or west), false = south (or east)
		node_y = north ? yo : yo + images.h;
		node_x = west ? xo : xo + images.w;
		return mouseInRect(px, py, node_x - NODE_DIM/2, node_y - NODE_DIM/2, NODE_DIM, NODE_DIM);
	});
	var mouseInAnyNode = (function(px, py) {
		return mouseInNode(px, py, true, true) || mouseInNode(px, py, true, false) || mouseInNode(px, py, false, true) || mouseInNode(px, py, false, false);
	});
	var mouseNode = (function(px, py) {
		if(mouseInNode(px, py, true, true)) return 'nwse';
		if(mouseInNode(px, py, false, false)) return 'nwse';
		if(mouseInNode(px, py, true, false)) return 'nesw';
		if(mouseInNode(px, py, false, true)) return 'nesw';
	});
	var mouseOnBorder = (function(px, py, line) {//line is 3, 6, 9 or 12, representing cardinal directions of clock to select line
		switch(line) {
		case 12:
			return mouseInRect(px, py, xo + NODE_DIM/2, yo - NODE_DIM/2, images.w - NODE_DIM, NODE_DIM/2);
		case 3:
			return mouseInRect(px, py, xo + images.w, yo + NODE_DIM/2, NODE_DIM/2, images.h - NODE_DIM);
		case 6:
			return mouseInRect(px, py, xo + NODE_DIM/2, yo + images.h, images.w - NODE_DIM, NODE_DIM/2);
		case 9:
			return mouseInRect(px, py, xo - NODE_DIM/2, yo + NODE_DIM/2, NODE_DIM/2, images.h - NODE_DIM);
		default: //never
			return false;
		}
	});
	var mouseOnAnyBorder = (function(px, py) {
		return mouseOnBorder(px, py, 12) || mouseOnBorder(px, py, 3) || mouseOnBorder(px, py, 6) || mouseOnBorder(px, py, 9);
	});
	switch(mouseStatus) {
	case INACTIVE:
		if(e.type == 'mouseenter') {
			mouseStatus = ACTIVE;
			$('#editor').css('cursor', 'default')
						.on('mousemove', handleMouse);
		}
		break;
	case ACTIVE:
		switch(e.type) {
		case 'mouseleave':
			mouseStatus = INACTIVE;
			$('#editor').css('cursor', 'default')
						.off('mousemove');
			break;
		case 'mousemove':
            if(mouseInImage(e.clientX, e.clientY)) { 
            	mouseStatus = FOCUSED; 
				$('#editor').css('cursor', 'move')
							.on('mousedown', handleMouse);
	            updateScreen();
			} else if(mouseInAnyNode(e.clientX, e.clientY)) {
				mouseStatus = FOCUSED;
				//test each node
				$('#editor').css('cursor', mouseNode(e.clientX, e.clientY)+'-resize');
				//set cursor based on result
			} else if(mouseOnAnyBorder(e.clientX, e.clientY)) {
				//if on any border
			} else {
				mouseStatus = ACTIVE;
				$('#editor').css('cursor', 'default');
			}
            break;
		}
		break;
	case FOCUSED:
		switch(e.type) {
		case 'mousemove':
            if(mouseInImage(e.clientX, e.clientY)) {
            	if($('#editor').css('cursor') != 'move') $('#editor').css('cursor', 'move'); 
			} else if(mouseInAnyNode(e.clientX, e.clientY)) {
				//if in any node
				$('#editor').css('cursor', mouseNode(e.clientX, e.clientY)+'-resize');
			} else if(mouseOnAnyBorder(e.clientX, e.clientY)) {
				//if on any border
			} else {
				mouseStatus = ACTIVE;
				$('#editor').css('cursor', 'default')
							.off('mousedown');
			}	
			updateScreen();
			break;
		case 'mouseleave':
			mouseStatus = INACTIVE;
			$('#editor').css('cursor', 'default')
						.off('mousedown')
						.off('mousemove');
			break;
		case 'mousedown':
            if(mouseInImage(e.clientX, e.clientY)) { 
            	mouseStatus = DRAGGING; 
				$('#editor').css('cursor', 'move')
							.off('mousemove')
							.on('mousemove', {x:e.pageX, y:e.pageY}, handleMouse)
							.on('mouseup', handleMouse);
				images.new_x = images.x;
				images.new_y = images.y;
	            updateScreen();
			} else if(mouseInAnyNode(e.clientX, e.clientY)) {
				//if in any node
			} else if(mouseOnAnyBorder(e.clientX, e.clientY)) {
				//if on any border
			} else {
				mouseStatus = ACTIVE;
				$('#editor').css('cursor', 'default')
							.off('mousedown');
			}	
			break;
		}
		$('#editor').css('cursor', 'move');
		break;
	case DRAGGING:
		switch(e.type) {
		case 'mousemove':
			if(e.shiftKey) {
				//modifier
			}
        	$('#editor').off('mousemove')
        				.on('mousemove', {x:e.pageX, y:e.pageY}, handleMouse);
        	if(e.data.hasOwnProperty('x')) {
        		images.new_x += e.pageX - e.data.x;
        		images.new_y += e.pageY - e.data.y;
        		updateScreen();
			}
			break;
		case 'mouseleave':
			images.x = images.new_x;
			images.y = images.new_y;
			delete images.new_x;
			delete images.new_y;
			$('#editor').off('mouseup')
						.off('mousemove');
			updateScreen();
			break;
		case 'mouseup':
			images.x = images.new_x;
			images.y = images.new_y;
			delete images.new_x;
			delete images.new_y;
			$('#editor').off('mouseup');
			if(mouseInImage(e.clientX, e.clientY)) {
				mouseStatus = FOCUSED;
			} else {
				mouseStatus = ACTIVE;
			}
			updateScreen();
			break;
		}
		
		$('#editor').css('cursor', 'move');
		
		break;
	case SCALING:
		switch(e.type) {
		case 'mousemove':
		
		
			break;
		case 'mouseleave':
			//stop scaling, but don't let go unless they mouseup
			break;
		case 'mouseup':
			break;
		}
		break;
	case CROPPING:
		switch(e.type) {
		case 'mousemove':
		
			break;
		case 'mouseleave':
			//probably shouldn't happen...
			break;
		case 'mouseup':
			break;
		}
		break;
	default:
		break; //should never happen
	}
	if(!images) {
		if(e.type == 'mouseenter') {
			mouseStatus = ACTIVE;
		} else {
			mouseStatus = INACTIVE;
		}
		return;
	}
	/*important in e:
	 *	e.shiftKey/e.ctrlKey (boolean)
	 *	e.pageX/e.screenX/e.clientX/e.offsetX (integral)
	 *	
	 */
	 
	 

}

function updateScreen(preview) {
	//vars
    var r = images.r != 0 ? images.r : false;
    var x = images.hasOwnProperty('new_x') ? images.new_x : images.x;
    var y = images.hasOwnProperty('new_y') ? images.new_y : images.y;
    var d_x = r === false ? 0 : -images.w / 2;
    var d_y = r === false ? 0 : -images.h / 2;
    var clip_to_board = $('#showclipping').is(':checked') && preview !== true;
    var draw_border = $('#showGuides').is(':checked') && !clip_to_board && preview !== true;
    //prep
    ctx.clearRect(0, 0, canv.width, canv.height);
    ctx.save();
    ctx.fillStyle = $('#bgcolor')[0].value;
    ctx.fillRect(0,0,canv.width,canv.height);
    ctx.restore();
    ctx.save();
    //transformations
    if(r !== false) { 
    	ctx.translate(x + images.h/2, y + images.w/2);
    	ctx.rotate(r) 
    } else { ctx.translate(x, y); }
    //draw image
    ctx.drawImage(images.i, 0, 0, images.i.width, images.i.height, d_x, d_y, images.w, images.h);
    //draw border, if needed  
    if (draw_border) {
        ctx.save();
        ctx.strokeStyle = (mouseStatus & (FOCUSED | DRAGGING | SCALING | CROPPING)) ? "#0FF" : "#F0F";
        ctx.lineWidth = 2.0;
        ctx.beginPath();
			//control nodes
			ctx.rect((d_x - 4), (d_y - 4), NODE_DIM, NODE_DIM);
			ctx.rect((d_x + images.w - 4), (d_y - 4), NODE_DIM, NODE_DIM);
			ctx.rect((d_x - 4), (d_y + images.h - 4), NODE_DIM, NODE_DIM);
			ctx.rect((d_x + images.w - 4), (d_y + images.h - 4), NODE_DIM, NODE_DIM);
            //border
            ctx.moveTo((d_x + 4), d_y);
            ctx.lineTo((d_x + images.w - 4), d_y);
            ctx.moveTo((d_x + images.w), (d_y + 4));
            ctx.lineTo((d_x + images.w), (d_y + images.h - 4));
            ctx.moveTo((d_x + images.w - 4), (d_y + images.h));
            ctx.lineTo((d_x + 4), (d_y + images.h));
            ctx.moveTo(d_x, (d_y + images.h - 4));
            ctx.lineTo(d_x, (d_y + 4));
        ctx.stroke();
        ctx.restore();
    }
	ctx.restore();
	ctx.save();
	//set up deck drawing deets
	ctx.strokeStyle = '#000';
	h = canv.height - 8;
	w = 3/11 * h;
	//set up compositing, if needed
	if(clip_to_board) {
		ctx.save();
		ctx.globalCompositeOperation = 'destination-in';
		ctx.fillRect(canv.width/2 - w/2, 4, w, h);
		ctx.restore();
	} 
	//draw deck cropping region
	if(preview !== true) {
		ctx.strokeRect(canv.width/2 - w/2, 4, w, h);
	}
	//restore for next time
	ctx.restore();
	//this image data should ONLY be retrieved when the user says they are done editing
	//it should be scaled to a normalized size for the site
	//then it should be displayed (pasted to new canvas)
	//lastly, the data itself should be sent with the rest of the entry's info
	//and then processed on the server into an actual image, saved, and waka waka waka
	//on save:
	/*canv_b.width = deck_img_data.width;
	canv_b.height = deck_img_data.height;
	ctx_b.putImageData(deck_img_data, 0, 0);
	deck_img = canv_b.toDataURL('image/png');*/
	
}


$(document).on('ready', init_editor);
function submit_entry(e) {
    var jqxhr = $.post('{% url submit_entry %}', 
    	{'title': $('input[name=title]')[0].value, 
    	'description': $('textarea[name=description]')[0].value, 
    	'tags': $('textarea[name=tags]')[0].value, 
    	'deck': $('input[name=deck]')[0].value/*.replace('data:image/png;base64,', '')*/,
    	'challenge': $('select[name=challenges]')[0].value
    	}, 
    	(function(data, textStatus, jqXHR) {
    		alert("Successfully saved changes.");
     		return true; //don't know if these have to actually do anything
    	}), 
    	'xml')
    jqxhr.fail(function(data, code, xhr) {
    	alert("Failed!");
    });   
}
$('input[value=subbbbbmit]').on('click', submit_entry);
</script>
{% endblock %}

{% block content %}
<div id="editpage">
	<span>First let's get that image!</span>
    <canvas id="editor" width="900px" height="900px"> </canvas>
	<canvas id="processor" width="1px" height="1px"> </canvas>
	<input type="file" id="imagely" />
	Show guides: <input type="checkbox" id="showGuides" />
	Clip: <input type="checkbox" id="showclipping" />
	Background: <input type="color" id="bgcolor" value="#ffffff" />
	<input type="button" name="preview" value="Preview!" />
</div>

<div id="previewpage">
	<span>And now for that info!</span>
<form method="POST" action=".">
	<img id="deckprev" src="" />
	<span id="title"><input type="text" name="title" placeholder="Title" /></span>
	<div id="entry">
		<section id="information">
  			<span id="entry_credit">Submitted by <a href="{% url view_user_profile user.id %}">{{ user.username }}</a></span>
  			<br />
  			<span id="entry_description"><textarea name="description" placeholder="Design description"></textarea></span> <br />
			<span id="entry_tag_list">
				<textarea name="tags" placeholder="Comma-separated tags"></textarea>
			</span>
			<select name="challenges">
				<option value="none">None</option>
				<option value="2">hallenge2</option>
			</select>
			{% csrf_token %}
			<input type="hidden" value="" name="deck" />
		</section>
	</div>
	<input type="button" value="subbbbbmit" name="submission" /><input type="button" value="cancel" name="goback" />
</form>
</div>
{% endblock %}
